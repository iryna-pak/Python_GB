# 1.Создать список и заполнить его элементами различных типов данных. Реализовать скрипт проверки типа данных
# каждого элемента. Использовать функцию type() для проверки типа. Элементы списка можно не запрашивать у пользователя,
# а указать явно, в программе.
print('\n************* Задание №1**************')
my_list = [8, "text", 2.6, True, 456]
for i in range(len(my_list)):
    print(f'{my_list[i]} - это {(type(my_list[i]))}')

# 2. Для списка реализовать обмен значений соседних элементов.
# Значениями обмениваются элементы с индексами 0 и 1, 2 и 3 и т. д. При нечётном количестве элементов последний
# сохранить на своём месте. Для заполнения списка элементов нужно использовать функцию input().
print('\n************* Задание №2**************')

lange = int(input("Введите количество элементов списка:  "))
my_list = []
i = 0
while i < lange:
    my_list.append(input("Введите элемент списка. Он может быть любого типа: "))
    i += 1

index = 0

for el in range(int(len(my_list)/2)):
    my_list[index], my_list[index + 1] = my_list[index + 1], my_list[index]
    index += 2
print(my_list)
'''
for element in my_list:
print(f'{element} - это {(type(element))}')
Цикл for in позволяет нам пройтись поэлементно по последовательности.
У пользователя можно сразу запросить ввести все элементы через пробел, например. А дальше получить список введенных элементов через функцию split()
'''
# 3.	Пользователь вводит месяц в виде целого числа от 1 до 12. Сообщить, к какому времени года относится
# месяц (зима, весна, лето, осень). Напишите решения через list и dict.
print('\n************* Задание №3**************')

my_month = int(input("Введите месяц в числовом виде "))
my_season_list = ['Зима', 'Весна', 'Лето', 'Осень']
my_season_dict = {1: 0, 2: 0, 3: 1, 4: 1, 5: 1, 6: 2, 7: 2, 8: 2, 9: 3, 10: 3, 11: 3, 12: 0}
if my_month in my_season_dict.keys():  # Проверка есть ли введённый месяц в списке ключей словаря
    str_season = my_season_list[my_season_dict.get(my_month)]  # выполнение справа на лево
    print(f"Введённый Вами месяц это {str_season}.")
else:
    print("Вы ввели не существующий месяц года!")

# 4.	Пользователь вводит строку из нескольких слов, разделённых пробелами.
# Вывести каждое слово с новой строки. Строки нужно пронумеровать. Если слово длинное, выводить только первые 
# 10 букв в слове.
print('\n************* Задание №4**************')

my_phrase = input('Введите предложение минимум из двух слов:  ')
num = 1
words = my_phrase.split()
for i in range(len(words)):
    if len(words[i]):
        print(f'{num} {words[i] [0:10]}')
        num += 1


# 5.	Реализовать структуру «Рейтинг», представляющую собой набор натуральных чисел, который не возрастает.
# У пользователя нужно запрашивать новый элемент рейтинга. Если в рейтинге существуют элементы с одинаковыми значениями,
# то новый элемент с тем же значением должен разместиться после них.
# Подсказка. Например, набор натуральных чисел: 7, 5, 3, 3, 2.
# Пользователь ввёл число 3. Результат: 7, 5, 3, 3, 3, 2.
# Пользователь ввёл число 8. Результат: 8, 7, 5, 3, 3, 2.
# Пользователь ввёл число 1. Результат: 7, 5, 3, 3, 2, 1.
# Набор натуральных чисел можно задать сразу в коде, например, my_list = [7, 5, 3, 3, 2].
print('\n************* Задание №5**************')

my_list1 = [7, 5, 3, 3, 2, 2]
print(f'Рейтинги - {my_list1}')
new_number = int(input('Введите число:  '))
if my_list1[0] < new_number:  # Если элемент в списке под индексом 0 меньше введённого элемента
    my_list1.insert(0, new_number)  # Вставить под индексом 0, введённый элемент
elif my_list1[-1] > new_number:  # Если элемент в списке под индексом -1(последний элемент) больше введённого элемента
    my_list1.append(new_number)  # Добавить введённый элемент в конец списка
else:
    for i in range(len(my_list1)):
        if my_list1[i] == new_number:  # Если элемент списка равен введённому
            my_list1.insert(i + 1, new_number)  # вставить рядом с равным элементом, введённый
            break
        elif my_list1[i] > new_number > my_list1[i + 1]:  # Если эл.списка больше введённого И эл.списка (индекс+1) меньше введённого
            my_list1.insert(i + 1, new_number)  # Вставить между элементами указанными в условии, введённый
            break
print(f'Текущий список - {my_list1}')

# 6.	*Реализовать структуру данных «Товары». Она должна представлять собой список кортежей.
# Каждый кортеж хранит информацию об отдельном товаре. В кортеже должно быть два элемента — номер товара и словарь
# с параметрами, то есть характеристиками товара: название, цена, количество, единица измерения. Структуру нужно
# сформировать программно, запросив все данные у пользователя.
# Пример готовой структуры:
# [(1, {“название”: “компьютер”, “цена”: 20000, “количество”: 5, “eд”: “шт.”}),
#  (2, {“название”: “принтер”, “цена”: 6000, “количество”: 2, “eд”: “шт.”}),
#  (3, {“название”: “сканер”, “цена”: 2000, “количество”: 7, “eд”: “шт.”})]
# Нужно собрать аналитику о товарах. Реализовать словарь, в котором каждый ключ — характеристика товара, например, 
# название. Тогда значение — список значений-характеристик, например, список названий товаров.
# Пример:{“название”: [“компьютер”, “принтер”, “сканер”],“цена”: [20000, 6000, 2000],“количество”: [5, 2, 7],“ед”: [“шт.”]}
print('\n************* Задание №6**************')

new_data, order = [], 1  # Пустой массив
title, price, gt, unit = None, None, None, None  # Значение не определено

while True:
    if title is None:
        title = input('Введите название товара: ')

    if price is None:
        price = int(input('Введите стоимость товара: '))

    if gt is None:
        gt = int(input('Введите количество товара: '))

    if unit is None:
        unit = input('Введите единицу измерения товара: ')

    new_data.append((order, {'title': title, 'price': price, 'gt': gt, 'unit': unit}))

    title, price, gt, unit = None, None, None, None
    order += 1

    print(new_data)

    ex_t = input('Если Вы закончили формирование списка товаров - введите Д. Если нет - введите Н:  ')
    if ex_t.lower() == 'д':
        break

analysis = {'title': [], 'price': [], 'gt': [], 'unit': set()}  # set - может быть пересечение значений

for _, el in new_data:  # _, Игнорировать значение определенного местоположения
    analysis['title'].append(el['title'])
    analysis['price'].append(el['price'])
    analysis['gt'].append(el['gt'])
    analysis['unit'].add(el['unit'])

print(analysis)
